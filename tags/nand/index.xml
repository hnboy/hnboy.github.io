<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>NAND - Tag - stay foolish stay hungry</title><link>https://hnboy.github.io/tags/nand/</link><description>NAND - Tag - stay foolish stay hungry</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 07 Feb 2026 16:35:00 +0800</lastBuildDate><atom:link href="https://hnboy.github.io/tags/nand/" rel="self" type="application/rss+xml"/><item><title>ONFI Spec Analysis Part 1: Architecture and Protocol Basics</title><link>https://hnboy.github.io/onfi-spec-analysis-part-1/</link><pubDate>Sat, 07 Feb 2026 16:35:00 +0800</pubDate><author>xxxx</author><guid>https://hnboy.github.io/onfi-spec-analysis-part-1/</guid><description><![CDATA[<h1 id="onfi-spec-analysis-part-1-architecture-and-protocol-basics">ONFI Spec Analysis Part 1: Architecture and Protocol Basics</h1>
<p>The <strong>Open NAND Flash Interface (ONFI)</strong> is a crucial industry standard that defines a common interface for NAND flash memory flakes and controllers. This post kicks off a series exploring the intricacies of the spec.</p>
<h2 id="1-why-onfi-matters">1. Why ONFI Matters</h2>
<p>Before ONFI, every NAND vendor had subtle differences in timing and pinouts. ONFI standardized this, allowing a single controller design to support multiple vendors (Micron, SK Hynix, Intel, etc.).</p>]]></description></item></channel></rss>